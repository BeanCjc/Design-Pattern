目的:
	当一个类的实例过程很昂贵或者很复杂,并且我们要创建多个这样类的实例,这是我们就可以通过对原对象进行clone来完成创建
	实际项目中一般很少单独使用原型模式.一般是和工厂方法一起出现,通过Clone方法创建一个对象,然后由工厂方法提供给调用者
优点:
	原型模式向客户端隐藏了创建新实例的复杂性
	原型模式允许动态增加或减少产品类
	原型模式简化了实例的创建结构,工厂方法模式需要有一个与产品类等级结构相同的等级结构,而原型模式不需要这样
	产品类不需要事先确定产品的等级结构,因为原型模式适用与任何等级结构
缺点:
	每个类必须有一个Clone方法
	Clone方法需要对类的功能进行通盘考虑,这对于全新的类不是很难,但对于已有的类不一定容易,特别当一个类引用不支持串行化的间接对象,或者引用含有循环结构的时候
应用:
	资源优化:类初始化需要消耗非常多的资源,包括数据库、硬件等
	性能和安全要求:通过new产生一个对象需要非常繁琐的数据准备或权限访问,则可以使用原型模式
	一个对象或多个修改者:一个对象需要提供给其他对象访问,而且各个调用者可能都需要修改其值时,可以考虑使用原型模式clone对个对象供调用者使用
.Net已提供了原型模式的实现接口ICloneable,该接口下的Clone方法